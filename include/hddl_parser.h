#ifndef HDDLPARSER_H
#define HDDLPARSER_H

#include <string>
#include <map>
#include "hddl_parser.tab.hpp" // automatically generated by bison

// Tell Flex the lexer's prototype ...
#define YY_DECL yy::parser::symbol_type yylex (HDDLParser& hddl_parser)
// ... and declare it for the parser's sake.
YY_DECL;

/*********************
 *
 * HDDL domain storing struct
 *
 *********************/

// e.g. ?r - robot ?source ?destination - location -> [r, robot], [source, location], [destination, location]
typedef std::vector<std::pair<std::string, std::string> > keyValueParams;

// e.g. (not (robot_at ?source)), (robot_at ?destination)
struct Predicate
{
    bool negated; // e.g. (-->not (robot_at ?source))
    std::string name; // e.g. (not (-->robot_at ?source))
    keyValueParams pred_params; // e.g. (not (robot_at -->?source))
};

/* Operator example
(:durative-action goto_waypoint
  :parameters (?r - robot ?source ?destination - location)
  :duration (= ?duration 10)
  :precondition (and
                  (robot_at ?r ?source)
                  (connected ?source ?destination)
                )
  :effect (and
            (not (robot_at ?r ?source))
            (robot_at ?r ?destination)
            (decrease (navigation-capacity) 1)
          )
)
*/
struct Operator
{
    std::string name_;
    keyValueParams params_;
    int duration_;
    std::vector<Predicate> preconditions_;
    std::vector<Predicate> effects_;
};

// stores a full hddl domain model
struct HDDLDomain
{
    // e.g. /home/user/foo_location/bar.hddl
    std::string domain_file_path_;

    std::string domain_name_;
    std::vector<std::string> domain_requirements_;
    std::vector<std::string> temp_instances_;
    std::map<std::string, std::string> domain_types_;
    std::vector<Predicate> domain_predicates_;
    std::vector<std::string> domain_functions_;
    std::vector<Operator> domain_operators_;
};

/*********************
 *
 * HDDL domain parser class, receives parsed information
 * from flex (scanner) and bison (grammar parser)
 *
 *********************/

class HDDLParser
{
  public:

  // --------- Constructor

    HDDLParser ();

  // --------- Methods

    // Run the parser on file F.  Return 0 on success.
    int parse(const std::string& f);

    // Handling scanner errors (unmatched tokens)
    void scan_begin();
    void scan_end();

    /* @brief safe access to parsing_ok_ by an external user
     * @return true if hddl parsing succeeded, false otherwise
     */
    bool parsing_ok();

  // --------- Member variables

    HDDLDomain domain_;

    // is set to true by the scanner of no errors occur
    bool parsing_ok_;

    // The token's location used by the scanner.
    yy::location location_;
};

#endif // ! HDDLPARSER_H
